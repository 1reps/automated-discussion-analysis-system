# 도메인 아키텍처 문서

## 📋 개요

이 문서는 ADAS(Automated Discussion Analysis System)의 도메인 아키텍처를 설명합니다. DDD(Domain-Driven Design) 원칙을 적용하여 각 도메인별로 명확한 경계와 책임을 가지도록 설계되었습니다.

## 🏗️ 아키텍처 구조

### 레이어 구조
```
📁 Presentation Layer (Controller)
    ↓
📁 Application Layer (Use Cases)
    ↓
📁 Domain Layer (Business Logic)
    ↓
📁 Infrastructure Layer (External Dependencies)
```

### 의존성 방향
- 모든 의존성은 안쪽(도메인)으로 향합니다
- 외부 레이어는 내부 레이어를 알 수 있지만, 내부 레이어는 외부 레이어를 알 수 없습니다

## 🎯 도메인 분할

### 1. Recording 도메인 (`com.adas.domain.recording`)
**책임**: 업로드된 오디오 파일의 메타데이터 관리

```java
// 핵심 엔티티
Recording {
    - id: Long
    - source: String (업로드 출처)
    - language: String (언어 힌트)
    - sizeBytes: Long (파일 크기)
    - durationMs: Long (재생 시간)
    - createdAt: Instant
}

// 도메인 메서드
+ createFromUpload(source, language, sizeBytes): Recording
+ specifyDuration(durationMs): void
+ markAsProcessedBy(source): void
```

**비즈니스 규칙**:
- 지속시간(duration)은 음수가 될 수 없음
- 처리 소스(source)는 null이나 빈 문자열이 될 수 없음

### 2. Transcript 도메인 (`com.adas.domain.transcript`)
**책임**: STT(Speech-To-Text) 전사 결과 관리

```java
// 핵심 엔티티
TranscriptSegment {
    - id: Long
    - recording: Recording (녹음 참조)
    - startMs: Long (시작 시간)
    - endMs: Long (종료 시간)
    - text: String (전사된 텍스트)
    - confidence: Double (신뢰도)
    - language: String (언어)
    - provider: String (제공업체)
}

// 도메인 메서드
+ transcribeSegment(...): TranscriptSegment
+ correctTranscription(correctedText): void
+ adjustConfidence(newConfidence): void
+ specifyLanguage(detectedLanguage): void
```

**비즈니스 규칙**:
- 시작 시간 < 종료 시간
- 신뢰도는 0.0 ~ 1.0 범위
- 텍스트는 최대 2000자
- 제공업체(provider)는 필수값

### 3. Diarization 도메인 (`com.adas.domain.diarization`)
**책임**: 화자 분리(Speaker Diarization) 결과 관리

```java
// 핵심 엔티티
DiarizationSegment {
    - id: Long
    - recording: Recording (녹음 참조)
    - speakerLabel: String (화자 레이블)
    - startMs: Long (시작 시간)
    - endMs: Long (종료 시간)
    - confidence: Double (신뢰도)
}

// 도메인 메서드
+ identifySpeaker(...): DiarizationSegment
+ adjustConfidence(newConfidence): void
+ correctSpeakerLabel(correctedLabel): void
```

**비즈니스 규칙**:
- 시작 시간 < 종료 시간
- 신뢰도는 0.0 ~ 1.0 범위 (null 허용)
- 화자 레이블은 필수값

### 4. Speaker 도메인 (`com.adas.domain.speaker`)
**책임**: 최종 화자 턴(발화 구간) 관리

```java
// 핵심 엔티티
SpeakerTurn {
    - id: Long
    - recording: Recording (녹음 참조)
    - speakerLabel: String (화자 레이블)
    - startMs: Long (시작 시간)
    - endMs: Long (종료 시간)
    - text: String (발화 내용)
}

// 도메인 메서드
+ createTurn(...): SpeakerTurn
+ extendTo(newEndMs): void
+ appendText(additionalText): void
+ assignToSpeaker(speakerLabel): void
```

**비즈니스 규칙**:
- 시작 시간 < 종료 시간
- 화자 레이블은 필수값
- 텍스트는 최대 4000자

### 5. Speech 도메인 (`com.adas.domain.speech`)
**책임**: STT와 Diarization 결과를 병합하여 화자 턴 생성

```java
// 핵심 도메인 모델
Turn {
    - speaker: String (final, 불변)
    - start: long
    - end: long
    - text: String
}

// 도메인 메서드
+ startSpeaking(speaker, startMs, endMs, initialText): Turn
+ extendSpeech(newEndMs, additionalText): void
+ isSameSpeaker(speakerLabel): boolean
+ getDurationMs(): long

// 도메인 서비스
SpeechMergeService {
    + merge(SttResponse, DiarizationResponse): List<Turn>
}
```

**비즈니스 규칙**:
- 화자는 생성 후 변경 불가 (불변성)
- 시간 범위 검증
- 겹침 기준으로 최적 화자 매칭

## 🔄 도메인 간 관계

### 의존성 방향
```
Speech Domain
    ↓ (사용)
Transcript Domain ← Recording Domain → Diarization Domain
    ↓                    ↓                      ↓
Speaker Domain ←────────┴──────────────────────┘
```

### 관계 설명
1. **Recording → 모든 도메인**: 모든 세그먼트와 턴은 특정 녹음에 속함
2. **Speech → Transcript + Diarization**: 병합 로직에서 두 도메인의 결과를 사용
3. **Speaker ← Recording**: 최종 화자 턴은 특정 녹음에 속함

## 🎨 설계 원칙

### 1. 단일 책임 원칙 (SRP)
- 각 도메인은 하나의 명확한 책임을 가짐
- Recording: 메타데이터, Transcript: 전사, Diarization: 화자분리, Speaker: 턴 관리

### 2. 의존성 역전 원칙 (DIP)
- Repository는 도메인 패키지에 인터페이스로 정의
- Infrastructure 레이어에서 구현체 제공

### 3. 도메인 순수성
- 도메인 모델은 프레임워크 의존성 최소화
- 비즈니스 로직은 도메인 메서드에 캡슐화

### 4. 불변성 (Immutability)
- Entity의 `@Setter` 제거
- 의미있는 도메인 메서드로 상태 변경
- Turn 도메인 모델의 화자는 불변

## 📱 Application 계층

### 구조
```
📁 com.adas.application/
├── 📁 media/              # 미디어 처리 유스케이스
│   └── MediaProcessingService.java
└── 📁 recording/          # 녹음 조회 유스케이스
    └── RecordingQueryService.java
```

### 책임 분리
- **MediaProcessingService**: 파일 업로드 → STT → Diarization → 병합 → 저장 전체 흐름
- **RecordingQueryService**: 저장된 데이터 조회 (녹음, 세그먼트, 턴)

## 🧪 테스트 전략

### 1. 도메인 모델 테스트
- 각 Entity의 생성, 검증, 상태 변경 로직 테스트
- 비즈니스 규칙 위반 시 적절한 예외 발생 검증

### 2. 도메인 서비스 테스트
- SpeechMergeService의 병합 로직 테스트
- 다양한 시나리오 (겹침, 공백, 정렬 등) 검증

### 3. Application 서비스 테스트
- Mock을 사용한 의존성 격리
- 전체 흐름의 오케스트레이션 검증

## 🎯 핵심 장점

### 1. 명확한 도메인 경계
- 각 도메인이 독립적인 패키지로 분리
- 관련 Entity + Repository가 함께 위치

### 2. 단방향 의존성
- 순환 의존성 제거
- 레이어 간 명확한 의존성 방향

### 3. 도메인 중심 설계
- 비즈니스 로직이 도메인 객체에 응집
- 의미있는 메서드명으로 도메인 지식 표현

### 4. 확장성
- 새로운 도메인 추가 시 기존 도메인에 영향 최소화
- 각 도메인별 독립적인 발전 가능

## 🔮 향후 개선 방향

### 1. 도메인 이벤트 도입
- 도메인 상태 변경 시 이벤트 발행
- 도메인 간 느슨한 결합 강화

### 2. Aggregate 패턴 적용
- 트랜잭션 경계 명확화
- 데이터 일관성 보장 강화

### 3. CQRS 패턴 고려
- Command와 Query 분리
- 읽기 성능 최적화

### 4. 도메인별 마이크로서비스 분리
- 각 도메인을 독립 서비스로 분리
- 서비스 간 API 통신으로 연동